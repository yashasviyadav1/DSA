# 63. Unique Paths II

### solved at : [Leetcode](https://leetcode.com/problems/unique-paths-ii/description/)


## Approach - 2 (dp + rec bruteforce)
```java
class Solution {
      
    /*⭐✔️ Approach - 2 (recursive bruteforce approach + dp)

            idea from approach - 1: at a cell, if first move 'right' to find total ways to reach end cell, then we move 'down' and find all total ways to reach end cell, ones we have both we add both totalWays and return the total.

            just add dp steps in this approach 1 i.e if we already know the total ways to reach the end for a particular cell then do not calculate again, rather use it to save time, and if we do not know the answer for a cell then calculate it and store in the dp, and we are good to submit
             
        T : O(n*m) - for any cell, we only calculate its value atmost 1 time
        S : O(n*m) - recursive space 

    */
    public int findTotalPaths(int matrix[][], int dp[][], int rowSize, int colSize, int row, int col){

        // if at the last cell, then we found a way
        if(row == rowSize - 1 && col == colSize - 1)
            return 1;
                        // R, D
        int deltaRow[] = {0, +1};
        int deltaCol[] = {+1, 0};
        int totalPaths = 0; // total paths to reach end cell from current cell {row,col}
        for(int i=0; i < 2; i++){

            int newRow = row + deltaRow[i];
            int newCol = col + deltaCol[i];
            if(newRow < rowSize && newCol < colSize && matrix[newRow][newCol] != 1){ // if its safe to move, i.e the next cell is in range of matrix, and there is not obstacle there
                // ans already calculated for this cell earlier
                if(dp[newRow][newCol] != -1)
                    totalPaths += dp[newRow][newCol];
                else totalPaths += findTotalPaths(matrix, dp, rowSize, colSize, newRow, newCol);
            }
        }

        return dp[row][col] = totalPaths; // save new Ans in dp
    } 

    public int uniquePathsWithObstacles(int[][] matrix) {

        int rowSize = matrix.length;
        int colSize = matrix[0].length;
        int dp[][] = new int[rowSize][colSize]; // dp matrix to store the already calculated ans for a cell

        // exceptions : 
        if(matrix[0][0] == 1 || matrix[rowSize-1][colSize-1] == 1) //robot initially standing at obstacle, cant move, if end cell is obstacle, cant reach
            return 0;

        for(int row=0; row < rowSize; row++)
            for(int col=0; col < colSize; col++)
                dp[row][col] = -1; // for remaining cells no answer is calculated yet
        

        return findTotalPaths(matrix, dp, rowSize, colSize, 0, 0); // initially robot is at cell {0,0}
    }
}
```

## Approach - 1 (bruteforce recursive)[java]
```java
class Solution {
     
    /*⚠️✔️ Approach - 1 (recursive bruteforce approach) - TLE

            idea : at a cell, if first move 'right' to find total ways to reach end cell, then we move 'down' and find all total ways to reach end cell, ones we have both we add both totalWays and return the total.

        T : O(2^(n*m)) - for every cell we got 2 choices to move to
        S : O(n*m) - recursive space 

    */
    public int findTotalPaths(int matrix[][], int rowSize, int colSize, int row, int col){

        // if at the last cell, then we found a way
        if(row == rowSize - 1 && col == colSize - 1)
            return 1;
                        // R, D
        int deltaRow[] = {0, +1};
        int deltaCol[] = {+1, 0};
        int totalPaths = 0; // total paths to reach end cell from current cell {row,col}
        for(int i=0; i < 2; i++){

            int newRow = row + deltaRow[i];
            int newCol = col + deltaCol[i];
            if(newRow < rowSize && newCol < colSize && matrix[newRow][newCol] != 1) // if its safe to move, i.e the next cell is in range of matrix, and there is not obstacle there
                totalPaths += findTotalPaths(matrix, rowSize, colSize, newRow, newCol);
        }

        return totalPaths;
    }

    public int uniquePathsWithObstacles(int[][] matrix) {
        
        if(matrix[0][0] == 1) //robot initially standing at obstacle, cant move
            return 0;

        int rowSize = matrix.length;
        int colSize = matrix[0].length;

        return findTotalPaths(matrix, rowSize, colSize, 0, 0); // initially robot is at cell {0,0}
    }
}
```
