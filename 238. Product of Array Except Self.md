# 238. Product of Array Except Self

### Solved at : [Leetcode](https://leetcode.com/problems/product-of-array-except-self/?envType=study-plan-v2&envId=top-interview-150)

## ✔️Approach - 2 (prefix,suffix products or array preprocesing T:O(n) S:O(2n)

here we do not have to apply out of bound conditions in 3rd loop coz our `prefix[i]` here stores product of elements from index 0 to i-1 and `suffix[i]` stores product of elements from index i+1 to n-1
```java
class Solution {
    // App-2.1 optimised preprocessing 
    // prefix[i] will means product of elements on left of i
    // suffix[i] means product of elements on right of i
    // T:O(n+n+n) S:O(n+n) 
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] prefixProduct = new int[n];
        int product = 1;
        for(int i=0; i < n; i++){
            prefixProduct[i] = product;
            product *= nums[i];
        }

        int[] suffixProduct = new int[n];
        product = 1;
        for(int i=n-1; i >= 0; i--){
            suffixProduct[i] = product;
            product *= nums[i];
        }

        // now ans[i] will store product of all numbers of array except ith no
        // which we can find by ans[i] = prefixProduct[i] * suffixProduct[i]
        // prefix[i] means product of nos on left of i
        // siffix[i] means product of nos on right of i
        int[] ans = new int[n];
        for(int i=0; i < n; i++){
            ans[i] = prefixProduct[i]*suffixProduct[i];
        }

        return ans;

    }
}
```

in below approach we have to make sure to apply conditions in 3rd loop coz `prefix[i]` stored product of nos from index 0 to i similarly for `suffix[i]` stored product of numbers from index i to n-1
```java
class Solution {
    // Approach - 2 (using prefix and suffix products or array preprocessing) 
    // prefix suffix products
    // Time : O(3n) Space O(2*n)
    public int[] productExceptSelf(int[] nums) {
        // concept : arr = {1  3  0  4  6}
        //           ans = {      72      }
        //                         ^
        //          ans[i] = prodct of left numbers* prodct of right nos
        //              i.e   (3*1)*(4*6) => 72

        int n = nums.length;
        int[] prefixProduct = new int[n]; // means prodct of nos from 0 till i index (left nos)
        int product = 1;
        for(int i=0; i < n; i++){ // going from left -> right
            product *= nums[i];
            prefixProduct[i] = product;
        }

        int[] suffixProduct = new int[n]; // means prodct of nos from i till n-1 index (right nos)
        product = 1;
        for(int i=n-1; i >= 0; i--){ // finding product from left <- right 
            product *= nums[i];
            suffixProduct[i] = product;
        }

        int[] ans = new int[n];
        for(int i=0; i < n; i++){
            int leftProduct = 1, rightProduct = 1;
            if(i-1 >= 0) leftProduct = prefixProduct[i-1];
            if(i+1 < n) rightProduct = suffixProduct[i+1];
            ans[i] = leftProduct * rightProduct;   // ans[i] is product of nos on its left * prod of nos on its right 
        }

        return ans;
    }
}
```

## ⚠️[TLE] Approach - 1 (Bruteforce)
```java
class Solution {
    // bruteforce T:O(n*n) S:O(n)
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] ans = new int[n];
        for(int i=0; i < n; i++){
            int product = 1;
            for(int j=0; j < n; j++){
                if(i == j) continue;
                product *= nums[j]; 
            }
            ans[i] = product;
        }
        return ans;
    }
}
```
