# 235. Lowest Common Ancestor of a Binary Search Tree


### Solved at : [Leetcode](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/)
### Dry Run 
![image](https://github.com/yashasviyadav1/DSA-Questions/assets/124666305/6e23a4ca-dd3e-4d66-979c-c91ee50870d3)


```cpp

/*✔️⭐ Approach - 1 (recursion)
    
    idea : recursively find p, q nodes in left and right subtrees, and the least node where both p, 1 are found that is the LCA 
    
    T : O(n)
    S : O(n) - recursive only

*/
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {

        // base cases - i) for a null tree, LCA is null   ii) every node is LCA of itself
        if(!root) return nullptr;
        if(root == p || root == q) return root;

        // recrusively find the LCA of left and right subtree
        TreeNode* leftLCA = lowestCommonAncestor(root -> left, p, q);
        TreeNode* rightLCA = lowestCommonAncestor(root -> right, p, q);

        if(leftLCA && rightLCA) return root; // if p and q was found each in both subtrees that means currently we are on LCA node
        
        // if 1 side's lca is null, and others lca is non null, return non null 
        if(leftLCA && !(rightLCA)) return leftLCA;
        else if(rightLCA && !(leftLCA)) return rightLCA;

        return nullptr; // p, q was not found
        
    }
};
```
