# 2385. Amount of Time for Binary Tree to Be Infected

### Solved at : [Leetcode](https://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/description/)

## ✔️Approach - 1 (convert Binary Tree to undirected graph, apply DFS)
![image](https://github.com/yashasviyadav1/DSA-Questions/assets/124666305/507ac0b7-c0ae-46c8-9639-551847ab0191)


```java
/* ✔️Approach - 1 (convert Binary Tree to undirected graph, apply DFS)

            idea : so the infection starts fom 'start' node so this is our 'src' but since our src might note be the root so how will we traverse from src to parent in case where our src is not root, so for that we need to convert this binary tree into undirectd graph for bidireactional traversal, so now from start as the src we apply DFS and at start time = 0, so go till all the depths and find time takn for all nodes to get infected .

        T : O(n+m) n=edges and m=nodes
        S : O(n+m) visited,AdjList,Recursion

*/
class Solution {

    int totalTime = 0; // this will store the totalTimeTaken for tree to get fully infected

    //2. this function will create undirected graph (AdjList) from a binary tree
    private void createAdjList(Map<Integer,ArrayList<Integer>> AdjList, TreeNode root){

        if(root == null) return;

        if(root.left != null){ // 
            ArrayList<Integer> li = AdjList.get(root.val);
            li.add(root.left.val);
            AdjList.put(root.val, li);
            li = AdjList.get(root.left.val);
            li.add(root.val);
            AdjList.put(root.left.val, li);
        }
        if(root.right != null){
            ArrayList<Integer> li = AdjList.get(root.val);
            li.add(root.right.val);
            AdjList.put(root.val, li);
            li = AdjList.get(root.right.val);
            li.add(root.val);
            AdjList.put(root.right.val, li);
        }

        createAdjList(AdjList, root.left);
        createAdjList(AdjList, root.right);
    } 

    // 1. this function will initialize the AdjList with creating empty list entry for each node and initializing visited map by setting value 'false' for each of the nodes
    void treeTraversal(TreeNode root, Map<Integer,ArrayList<Integer>> AdjList, Map<Integer, Boolean> visited){

        if(root == null)
            return;

        if(!AdjList.containsKey(root.val))
            AdjList.put(root.val, new ArrayList<Integer>());
        if(!visited.containsKey(root.val))
            visited.put(root.val, false);

        treeTraversal(root.left, AdjList, visited);
        treeTraversal(root.right, AdjList, visited);
    }

    // 3. this fuction will traverse tree in using depth first search 
    private void DFS(Map<Integer,ArrayList<Integer>> AdjList, Map<Integer,Boolean> visited, int src, int time){
        
        if(time > this.totalTime) // update the global time for totalTree to get Infected if we got a greater 'time' 
            this.totalTime = time; 
            
        visited.put(src, true); // mark current node as visited

        for(int neigh:AdjList.get(src)){  // explore depths of all neighs of src node one by one
            if(visited.get(neigh) == false) // go to depth of only non visited nodes
                DFS(AdjList, visited, neigh, time + 1);  // suppose for 'src' to get infected it to 'time' then for its all neighs will take 'time + 1' to get infected
        }

    }

    public int amountOfTime(TreeNode root, int start) {

        //convert bt into a undirected graph
        Map<Integer,ArrayList<Integer>> AdjList = new HashMap<>();
        Map<Integer, Boolean> visited = new HashMap<Integer,Boolean>();

        treeTraversal(root, AdjList, visited); // this will create default blocks for AdjList and visited map to avoid the null pointer error 
        createAdjList(AdjList, root);  // convert Binary tree to AdjList

        // for(int key:AdjList.keySet()){  // printing AdjList for error handling purpose
        //     System.out.print(key + " -> ");
        //     System.out.print(AdjList.get(key));
        //     System.out.println();
        // }

        int time = 0; // to get infected  
        DFS(AdjList, visited, start, time); // find the time taken for complete tree to get infected using DFS
 
        return this.totalTime;

    }
}

```
